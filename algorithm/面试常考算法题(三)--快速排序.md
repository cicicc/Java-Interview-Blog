![](https://img.hacpai.com/bing/20180211.jpg?imageView2/1/w/960/h/520/interlace/1/q/100) 

# 面试常考算法题(三)--快速排序

## 快速排序

### 经典快速排序

快速排序（Quicksort）是对冒泡排序的一种改进。

快速排序由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以`递归`进行，以此达到整个数据变成有序序列。

#### 经典快排思路

以下举例部分来自于[坐在马桶上看算法：快速排序](http://developer.51cto.com/art/201403/430986.htm),由于原文已经有较为优秀的解说,在这一篇文章中就不再额外举例重复说明经典快排原理.

有没有既不浪费空间又可以快一点的排序算法呢？那就是“快速排序”啦！光听这个名字是不是就觉得很高端呢。

假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：

3  1  2 5  4  6  9 7  10  8

在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6。想一想，你有办法可以做到这点吗？

**排序算法显神威**

方法其实很简单：分别从初始序列“6  1  2 7  9  3  4  5 10  8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。这里可以用两个变量i和j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵i”和“哨兵j”。刚开始的时候让哨兵i指向序列的最左边（即i=1），指向数字6。让哨兵j指向序列的最右边（即=10），指向数字。
![imagepng](http://pcg4drw32.bkt.clouddn.com//file/2018/09/91b5119ec6e94006bca2907d30a5aa1d_image.png) 
首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（**请自己想一想为什么**）。哨兵j一步一步地向左挪动（即j--），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。
![imagepng](http://pcg4drw32.bkt.clouddn.com//file/2018/09/fedeb90ccb1642268ba34e673b9f9548_image.png)
![imagepng](http://pcg4drw32.bkt.clouddn.com//file/2018/09/d3183882bb65449492011f20d2260a45_image.png) 
  现在交换哨兵i和哨兵j所指向的元素的值。交换之后的序列如下：

6   1   2   **5**  9   3   4  **7**   10   8
![imagepng](http://pcg4drw32.bkt.clouddn.com//file/2018/09/313d248217cb4b82ac34c98dbd219522_image.png) 

到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换，交换之后的序列如下：
6  1  2 5  **4**  3  **9**  7 10  8

第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。交换之后的序列如下：

**3**  1 2  5  4  **6**  9 7  10  8
![imagepng](http://pcg4drw32.bkt.clouddn.com//file/2018/09/6640fe212022487fbcd617c5b94a4f89_image.png) 

到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。回顾一下刚才的过程，其实哨兵j的使命就是要找小于基准数的数，而哨兵i的使命就是要找大于基准数的数，直到i和j碰头为止。

OK，解释完毕。现在基准数6已经归位，它正好处在序列的第6位。此时我们已经将原来的序列，以6为分界点拆分成了两个序列，左边的序列是“3  1 2  5  4”，右边的序列是“9  7  10  8”。接下来还需要分别处理这两个序列。因为6左边和右边的序列目前都还是很混乱的。不过不要紧，我们已经掌握了方法，接下来只要模拟刚才的方法分别处理6左边和右边的序列即可。现在先来处理6左边的序列现吧。

左边的序列是“3  1  2 5  4”。请将这个序列以3为基准数进行调整，使得3左边的数都小于等于3，3右边的数都大于等于3。好了开始动笔吧

如果你模拟的没有错，调整完毕之后的序列的顺序应该是：

2  1  3  5  4

OK，现在3已经归位。接下来需要处理3左边的序列“2 1”和右边的序列“5 4”。对序列“2 1”以2为基准数进行调整，处理完毕之后的序列为“1 2”，到此2已经归位。序列“1”只有一个数，也不需要进行任何处理。至此我们对序列“2 1”已全部处理完毕，得到序列是“1 2”。序列“5 4”的处理也仿照此方法，最后得到的序列如下：

1  2  3 4  5  6 9  7  10  8

对于序列“9  7  10  8”也模拟刚才的过程，直到不可拆分出新的子序列为止。最终将会得到这样的序列，如下

1  2  3 4  5  6  7  8 9  10

到此，排序完全结束。细心的同学可能已经发现，`快速排序的每一轮处理其实就是将这一轮的基准数归位`，直到所有的数都归位为止，排序就结束了。下面上个霸气的图来描述下整个算法的处理过程。

### 经典快排代码
```java
   public static void quickSort(int[] a){
        if (a == null || a.length < 2) {
            return;
        }
        quickSort(a, 0, a.length - 1);
    }

    public static void quickSort(int[] arr, int low, int high) {
        int start = low;
        int end = high;
        int key = arr[low];
        while (end > start) {
            //从后往前比较
            while (end > start && arr[end] >= key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
                end--;
            if (arr[end] <= key) {
                swap(arr, start, end);
            }
            //从前往后比较
            while (end > start && arr[start] <= key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
                start++;
            if (arr[start] >= key) {
                swap(arr, end, start);
            }
            //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
        }
        //递归
        if (start > low) {
            quickSort(arr, low, start - 1);//左边序列。第一个索引位置到关键值索引-1
        }
        if (end < high) {
            quickSort(arr, end + 1, high);//右边序列。从关键值索引+1到最后一个
        }
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[j];
        arr[j] = arr[i];
        arr[i] = temp;
    }


```

### 快速排序比较快的原因
快速排序之所比较快，因为相比冒泡排序，每次交换是跳跃式的。每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的`最差时间复杂度`和冒泡排序是一样的都是`O(N^2)`，它的平均时间复杂度为`O(NlogN)`。其实快速排序是基于一种叫做“二分”的思想。


### 快排算法在什么时候最慢
最坏情况下，是整个序列都已经有序或完全倒序,此时，快速排序`退化为冒泡排序`，要比较n2次才能完成

### 使用荷兰国旗思想优化快速排序代码
在[面试常考算法题二](http://www.indispensable.cn/articles/2018/09/20/1537366515194.html)中,我们讲到了荷兰国旗问题,在快速排序中可以使用荷兰国旗问题所采用的思想,即将每次划分的中间区域用来存放当前`基数`.
```Java
 public static void quickSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return;
        }
        quickSort(arr, 0, arr.length - 1);
    }

    public static void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            //下面一句话就是为了避免当前的数组已经为完全有序或者反序的状态
            swap(arr, left + (int) (Math.random() * (right - left + 1)), right);
            int[] p = partition(arr, left, right);//返回等于基数的起始位置和结束位置
            quickSort(arr, left, p[0] - 1);
            quickSort(arr, p[1] + 1, right);
        }
    }

    public static int[] partition(int[] arr, int left, int right) {
        int less = left - 1;
        int more = right;
        while (left < more) {
            if (arr[left] < arr[right]) {
                swap(arr, ++less, left++);
            } else if (arr[left] > arr[right]) {
                swap(arr, --more, left);
            } else {//arr[left] == arr[right]
                left++;
            }
        }
        swap(arr, more, right);
        return new int[] { less + 1, more };
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

```



